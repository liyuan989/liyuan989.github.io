<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="有人说指针是c语言的灵魂，也有人说没学好指针就等于不会c语言。
虽然在现代c++中一般都是推荐尽量避免使用原生的raw指针，而是以smart pointer 和reference替代之。但是无论怎样，对于c/c++来说，指针始终是个绕不过去的坎。究其原因，是因为c/c++都是支持面向底层操作的语言，而面向底层操作就得能操纵内存，这个时候就需要指针了。为什么呢？个人觉得指针实际上就是对机器语言/as">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈指针的比较">
<meta property="og:url" content="http://originlee.com/2015/01/24/pointer-compare/index.html">
<meta property="og:site_name" content="Less is more">
<meta property="og:description" content="有人说指针是c语言的灵魂，也有人说没学好指针就等于不会c语言。
虽然在现代c++中一般都是推荐尽量避免使用原生的raw指针，而是以smart pointer 和reference替代之。但是无论怎样，对于c/c++来说，指针始终是个绕不过去的坎。究其原因，是因为c/c++都是支持面向底层操作的语言，而面向底层操作就得能操纵内存，这个时候就需要指针了。为什么呢？个人觉得指针实际上就是对机器语言/as">
<meta property="og:updated_time" content="2016-06-19T17:21:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈指针的比较">
<meta name="twitter:description" content="有人说指针是c语言的灵魂，也有人说没学好指针就等于不会c语言。
虽然在现代c++中一般都是推荐尽量避免使用原生的raw指针，而是以smart pointer 和reference替代之。但是无论怎样，对于c/c++来说，指针始终是个绕不过去的坎。究其原因，是因为c/c++都是支持面向底层操作的语言，而面向底层操作就得能操纵内存，这个时候就需要指针了。为什么呢？个人觉得指针实际上就是对机器语言/as">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 浅谈指针的比较 - Less is more </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <!--
      <span class="logo-line-before"><i></i></span>
      -->
      <span class="site-title">Less is more</span>
      <!--
      <span class="logo-line-after"><i></i></span>
      -->
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                浅谈指针的比较
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-24T15:19:00+08:00" content="2015-01-24">
              2015-01-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/01/24/pointer-compare/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/24/pointer-compare/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>有人说指针是c语言的灵魂，也有人说没学好指针就等于不会c语言。</p>
<p>虽然在现代c++中一般都是推荐尽量避免使用原生的raw指针，而是以smart pointer 和reference替代之。但是无论怎样，对于c/c++来说，指针始终是个绕不过去的坎。究其原因，是因为c/c++都是支持面向底层操作的语言，而面向底层操作就得能操纵内存，这个时候就需要指针了。为什么呢？个人觉得指针实际上就是对机器语言/asm中的通过虚拟地址操作内存的这一行为的一种抽象。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl %eax, (%edx)</span><br></pre></td></tr></table></figure>
<p>将寄存器eax中的值写入内存地址为寄存器edx的值的内存中。如果把edx看做一个指针的话，也就相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*p_edx = value_eax</span><br></pre></td></tr></table></figure>
<h2 id="1-指针的比较"><a href="#1-指针的比较" class="headerlink" title="1. 指针的比较"></a>1. 指针的比较</h2><p>关于指针，有着许多技巧和用途，后文主要谈谈关于c++中指针比较操作的一些容易踏入的坑。</p>
<p>先来看看这段代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Derived derivd;</span><br><span class="line">    Derived* pd = &amp;derivd;</span><br><span class="line">    BaseB* pb = &amp;derivd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pb = %p\n"</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pd = %p\n"</span>, pd);</span><br><span class="line">    <span class="keyword">if</span> (pb == pd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pb == pd\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pb != pd\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pb = 0028FEE0</span><br><span class="line">pd = 0028FED8</span><br><span class="line">pb == pd</span><br></pre></td></tr></table></figure></p>
<p>可以看到指针pb和pd值并不一样，但是编译器却认为他们相等，为什么呢？<a id="more"></a></p>
<p>1.  当2个指针的静态类型以及所指对象的类型都属于同一个继承层次结构中，并且其中一个指针类型是所指对象的静态类型的时候，指针的比较，实际上比较的是两个指针是否指向同一个对象。</p>
<p>若2个指针指向同一个对象，被编译器决议为相等。编译器在比较的时候加上适当的offset值，例如上面的情况，相当于在比较的时候编译器做了这样的改动:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((pb - <span class="keyword">sizeof</span>(<span class="keyword">int</span>) == pd)</span><br></pre></td></tr></table></figure></p>
<p>offset是由c++对象的内存模型决定的，具体的就不再本文讨论的范畴了。</p>
<p>若2个指针指向不同的对象，就被决议为不相等，并且比较的是指针保存的地址的值的大小。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Derived derived1;</span><br><span class="line">    Derived derived2;</span><br><span class="line">    Derived* pd = &amp;derived1;</span><br><span class="line">    BaseB* pb = &amp;derived2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, pd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, pb);</span><br><span class="line">    <span class="keyword">if</span> (pd &lt; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pd &lt; pb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pd == pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pd == pb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pd &gt; pb\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到的结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0028FED8</span><br><span class="line">0028FED0</span><br><span class="line">pd &gt; pb</span><br></pre></td></tr></table></figure></p>
<p>2.  当2个指针的静态类型不属于同一个继承层次结构中，但是2个指针都指向同一个对象的时候，该比较是违法行为，编译器会报编译期错误<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Derived derivd;</span><br><span class="line">    Derived* pd = &amp;derivd;</span><br><span class="line">    <span class="keyword">int</span>* pb = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;derivd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pb = %p\n"</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pd = %p\n"</span>, pd);</span><br><span class="line">    <span class="keyword">if</span> (pb == pd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pb == pd\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pb != pd\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器报错为：</p>
<blockquote>
<p>error: comparison between distinct pointer types ‘int<em>‘ and ‘Derived</em>‘ lacks a cast [-fpermissive]&gt;<br>if (pb == pd)</p>
</blockquote>
<p>3.  当2个指针的静态类型以及所指对象类型都属于同一个继承层次结构，但是2个指针的静态类型都不是所指对象的类型时，该比较是违法行为，编译器会报编译期错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Derived derivd;</span><br><span class="line">    BaseB* pb = &amp;derivd;</span><br><span class="line">    BaseA* pa = &amp;derivd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pb = %p\n"</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pd = %p\n"</span>, pa);</span><br><span class="line">    <span class="keyword">if</span> (pb == pa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pb == pa\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pb != pa\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器报错为：</p>
<blockquote>
<p>error: comparison between distinct pointer types ‘BaseB<em>‘ and ‘BaseA</em>‘ lacks a cast&gt;<br>if (pb == pa)</p>
</blockquote>
<p>另外一些其他的行为，例如2个指针的类型不同但同属于一个继承层次，然后通过强制类型转换让他们俩都指向一个不属于该继承层次的对象，这样的行为都是为未定义行为，也许编译器不会报编译期错误，但结果是未定义的，可能是任何结果。</p>
<p>可能有人会说，什么时候指针比较的是他们所保存的地址的值呢呢？</p>
<p>答案是当2个指针的静态类型相同的时候：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Derived derived1;</span><br><span class="line">    Derived derived2;</span><br><span class="line">    Derived* p1 = &amp;derived1;</span><br><span class="line">    Derived* p2 = &amp;derived2;</span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p1 &lt; p2\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p1 == p2\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"p1 &gt; p2\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：p1 &gt; p2</p>
<h2 id="2-shared-ptr的owner-before"><a href="#2-shared-ptr的owner-before" class="headerlink" title="2. shared_ptr的owner_before"></a>2. shared_ptr的owner_before</h2><p>boost::shared_ptr/std::shared_ptr中有一个owner_before成员函数，原型为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> u&gt; <span class="function"><span class="keyword">bool</span> <span class="title">owner_before</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;u&gt;&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> u&gt; <span class="function"><span class="keyword">bool</span> <span class="title">owner_before</span> <span class="params">(<span class="keyword">const</span> weak_ptr&lt;u&gt;&amp; x)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>当该shared_ptr和x的类型同属一个继承层次时，不管他们类型是否相同，他们两都被决议为“相等”。当他们的类型不属于同一继承层次时，比较的为他们所管理指针的地址值的大小。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;Derived&gt; pd(<span class="keyword">new</span> Derived);</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;BaseB&gt; pb(pd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p %p\n"</span>, pd.get(), pb.get());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pd &lt; pb, pb &lt; pd);  <span class="comment">// 0 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, pd.owner_before(pb), pb.owner_before(pd));  <span class="comment">// 0 0</span></span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; p0(pd), p1(pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p %p\n"</span>, p0.get(), p1.get());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p0.get() &lt; p1.get(), p1.get() &lt; p0.get());  <span class="comment">// 1 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p0.owner_before(p1), p1.owner_before(p0));  <span class="comment">// 0 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么shared_ptr会提供这样的成员函数呢？</p>
<p>因为一个智能指针有可能指向了另一个智能指针指向对象中的某一部分，但又要保证这两个智能指针销毁时，只对那个被指的对象完整地析构一次，而不是两个指针分别析构一次。</p>
<p>在这种情况下，指针就可以分为两种，一种是 stored pointer 它是指针本身的类型所表示的对象（可能是一个大对象中的一部分）；另一种是 owned pointer 指向内存中的实际完整对象（这一个对象可能被许多智能指针指向了它里面的不同部分，但最终只析构一次）。owner-based order 就是指后一种情况，如果内存中只有一个对象，然后被许多 shared pointer 指向了其中不同的部分，那么这些指针本身的地址肯定是不同的，也就是operator&lt;()可以比较它们，并且它们都不是对象的 owner，它们销毁时不会析构对象。但它们都指向了一个对象，在owner-based order 意义下它们是相等的。</p>
<p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/owner_before/" target="_blank" rel="external">cpluscplus</a>中是这样解释的：</p>
<blockquote>
<p>returns whether the object is considered to go before <em>x</em> following a strict weak <em>owner-based</em> order.&gt;</p>
<p>unlike the <a href="http://www.cplusplus.com/shared_ptr:operators" target="_blank" rel="external">operator&lt; overload</a>, this ordering takes into consideration the <a href="http://www.cplusplus.com/shared_ptr" target="_blank" rel="external">shared_ptr</a>‘s <em>owned pointer</em>, and not the <a href="http://www.cplusplus.com/shared_ptr::get" target="_blank" rel="external">stored pointer</a> in such a way that two of these objects are considered equivalent (i.e., this function returns <tt>false </tt>no matter the order of the operands) if they both share ownership, or they are both empty, even if their <a href="http://www.cplusplus.com/shared_ptr::get" target="_blank" rel="external">stored pointer</a> value are different.&gt;</p>
<p>the <em>stored pointer</em> (i.e., the pointer the <a href="http://www.cplusplus.com/shared_ptr" target="_blank" rel="external">shared_ptr</a> object <a href="http://www.cplusplus.com/shared_ptr::operator*" target="_blank" rel="external">dereferences</a> to) may not be the <em>owned pointer</em> (i.e., the pointer deleted on object destruction) if the <a href="http://www.cplusplus.com/shared_ptr" target="_blank" rel="external">shared_ptr</a> object is an alias (<a href="http://www.cplusplus.com/shared_ptr::shared_ptr" target="_blank" rel="external">alias-constructed</a> objects and their copies).&gt;</p>
<p>this function is called by <a href="http://www.cplusplus.com/owner_less" target="_blank" rel="external">owner_less</a> to determine its result.</p>
</blockquote>
<p><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/owner_before" target="_blank" rel="external">cppreference</a>中的解释：</p>
<blockquote>
<p>checks whether this shared_ptr precedes other in implementation defined owner-based (as opposed to value-based) order. the order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object)&gt;</p>
<p>this ordering is used to make shared and weak pointers usable as keys in associative containers, typically through <span class="t-lc"><a href="http://en.cppreference.com/w/cpp/memory/owner_less" title="cpp/memory/owner less" target="_blank" rel="external">std::owner_less</a>.</span></p>
</blockquote>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul>
<li>指针之间的比较，要么指针的静态类型相同，要么指针的静态类型不同但他们的类型同属于同一继承层次且其中一个指针的静态类型为所指对象的类型。</li>
<li>指针的静态类型相同时，比较的是地址的值的大小。</li>
<li>指针的静态类型不同，但是他们的类型属于同一继承层次，并且其中一个指针的静态类型为所指对象的类型时，比较的是两指针是否指向同一对象。若是指向同一对象，则两指针“相等”；若不是指向同一对象，则比较指针的地址值的大小。</li>
<li>智能指针shared_ptr/weak_ptr的onwer_before成员函数描述的是：当比较的2个智能指针的类型属于同一继承层次时表现为“相等”的含义；当2个智能指针的类型不属于同一继承层次时，比较的是所管理指针的地址值的大小。</li>
</ul>
<h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h2><ol>
<li>cplusplus. <a href="http://www.cplusplus.com/reference/memory/shared_ptr/owner_before/" target="_blank" rel="external">std::shared_ptr::owner_before</a></li>
<li>cppreference. <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/owner_before" target="_blank" rel="external">std::shared_ptr::owner_before</a><br>（完）</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/01/21/trick-in-conditon-variable/" rel="next" title="条件变量的陷阱与思考">
                <i class="fa fa-chevron-left"></i> 条件变量的陷阱与思考
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/01/31/thread-safe-singleton-in-cxx/" rel="prev" title="C++中多线程与Singleton的那些事儿">
                C++中多线程与Singleton的那些事儿 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Li Yuan" />
          <p class="site-author-name" itemprop="name">Li Yuan</p>
          <p class="site-description motion-element" itemprop="description">种一棵树最好的时间是十年前，其次是现在</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">29</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:liyuan989@gmail.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://cn.linkedin.com/in/liyuan989" target="_blank">
                  
                    <i class="fa fa-linkedin"></i>
                  
                  LinkedIn
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/liyuan989" target="_blank">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/origin-989" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/liyuan989" target="_blank">
                  
                    <i class="fa fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-指针的比较"><span class="nav-number">1.</span> <span class="nav-text">1. 指针的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-shared-ptr的owner-before"><span class="nav-number">2.</span> <span class="nav-text">2. shared_ptr的owner_before</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-总结"><span class="nav-number">3.</span> <span class="nav-text">3. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-参考文献"><span class="nav-number">4.</span> <span class="nav-text">4. 参考文献</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;
   2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Yuan</span>
</div>
<!--
<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
-->


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'originlee';
      var disqus_identifier = '2015/01/24/pointer-compare/';
      var disqus_title = '浅谈指针的比较';
      var disqus_url = 'http://originlee.com/2015/01/24/pointer-compare/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  

  

  

</body>
</html>
